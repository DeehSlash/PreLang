#Options
GenerateScanner = true
GenerateParser = true
Language = Java
ScannerName = Lexico
ParserName = Sintatico
SemanticName = Semantico
Package = gals
ScannerCaseSensitive = true
ScannerTable = Compact
Input = String
Parser = SLR
#RegularDefinitions
ignore: [\t\r\s]+|(#.*\n)|[#][!][#-~,\n\r\s\t\b]+[!][#]*
identifier: [a-zA-Z_][a-zA-Z0-9_]*

// TYPES
int: [0-9]+
float: [0-9]*\.[0-9]+
boolean: true | TRUE | false | FALSE
binary: 0b[0-1]+
hexadecimal: 0x[0-9a-fA-F]+
string: \"[^\"]*\"
#Tokens
: {ignore}
NEW_LINE: \n

MAIN_FUNCTION: "@main"
PRINT: "@print"
INPUT: "@input"

VAR: "$"{identifier}
CONST: "&"{identifier}
FUNCTION: "@"{identifier}

// CONDITIONAL
IF: "if"
ELSE: "else"
ELSIF: "elsif"
SWITCH: "switch"
CASE: "case"
DEFAULT: "default"

// LOOP
WHILE: "while"
DO: "do"
FOR: "for"
CONTINUE: "continue"

// OTHERS RESERVED WORDS
BREAK: "break" 
COMMA: ","
STRUCTURE_REFERENCE: "."
COLON: ":"
RETURN: "return"
IN: "in"
NULL: "null"

FUNCTION_RETURN: "->"

SCOPE_OPEN: "{"
SCOPE_CLOSE: "}"

SUBGROUP_OPEN: "("
SUBGROUP_CLOSE: ")"

INDEX_OPEN: "["
INDEX_CLOSE: "]"

IN: "in"
RANGE: "range"

// VALUES
INT: {int}
FLOAT: {float}
BOOLEAN: {boolean}
BINARY: {binary}
HEXADECIMAL: {hexadecimal}
STRING: {string}

// ARITHMETIC OPERATORS
OP_ASSIGN: "="
OP_ADD: "+"
OP_SUB: "-"
OP_MULT: "*"
OP_DIV: "/"
OP_MOD: "%"
OP_INC: "++"
OP_DEC: "--"

// RELATIONAL OPERATORS
OP_LT: "<"
OP_LTE: "<="
OP_EQ: "=="
OP_NEQ: "!="
OP_GT: ">"
OP_GTE: ">="

// LOGICAL OPERATORS
OP_AND: "&&"
OP_OR: "||"
OP_NOT: "!"

// BITWISE OPERATORS
OP_BW_NOT: "~"
OP_BW_AND: "&"
OP_BW_OR: "|"
OP_BW_XOR: "^"
OP_BW_LS: "<<"
OP_BW_RS: ">>"

// PRIMITIVE TYPES
TYPE_VOID: "void"
TYPE_INT: "int"
TYPE_FLOAT: "float"
TYPE_DOUBLE: "double"
TYPE_STRING: "string"
TYPE_CHAR: "char"
TYPE_BOOLEAN: "boolean"
#NonTerminals
<program>
<main_function>
<function_list>
<function>

<fn_parameter_list>
<fn_parameters>
<fn_parameter>

<parameter_list>
<parameters>
<parameter>

<type>
<type_values>
<array_values>
<array_size>
<new_line>

<scope>

<command_list>
<command>

<array>
<attribute>
<attributes>

<if>
<else>
<single_elsif>
<elsif>

<while>
<do_while>
<for>
<range>
<range_types>

<exp>
<exp1>
<exp2>
<exp3>
<exp4>
<exp5>
<exp6>
<exp7>
<exp8>
<exp9>
<exp10>

<op_relational>
<op_negate>
<op_bitwise>
<op_arithmetic_low>
<op_arithmetic_high>
<op_arithmetic_higher>
#Grammar
<program> ::= <main_function> | <new_line> <main_function> | <function_list> <main_function> | <new_line> <function_list> <main_function>;
<main_function> ::= MAIN_FUNCTION <fn_parameter_list> FUNCTION_RETURN <type> <scope> <new_line>;
<function_list> ::= <function> | <function> <function_list>;
<function> ::= FUNCTION <fn_parameter_list> FUNCTION_RETURN <type> <scope> <new_line>;

<fn_parameter_list> ::= SUBGROUP_OPEN <fn_parameters> SUBGROUP_CLOSE | SUBGROUP_OPEN SUBGROUP_CLOSE;
<fn_parameters> ::= <fn_parameter> | <fn_parameter> COMMA <fn_parameters>;
<fn_parameter> ::= VAR COLON <type>;

<parameter_list> ::= SUBGROUP_OPEN <parameters> SUBGROUP_CLOSE | SUBGROUP_OPEN SUBGROUP_CLOSE;
<parameters> ::= <parameter> | <parameter> COMMA <parameters>;
<parameter> ::= VAR | <type_values>;

<type> ::= TYPE_INT | TYPE_FLOAT | TYPE_DOUBLE | TYPE_STRING | TYPE_CHAR | TYPE_BOOLEAN;
<type_values> ::= INT | FLOAT | BOOLEAN | BINARY | HEXADECIMAL | STRING | <array>;
<array_values> ::= INDEX_OPEN <parameters> INDEX_CLOSE;
<array_size> ::= INDEX_OPEN INT INDEX_CLOSE | INDEX_OPEN INDEX_CLOSE;
<new_line> ::= NEW_LINE | NEW_LINE <new_line>;

<scope> ::= SCOPE_OPEN <new_line> <command_list> SCOPE_CLOSE | SCOPE_OPEN <new_line> SCOPE_CLOSE;

<command_list> ::= <command> <new_line> | <command> <new_line> <command_list>;
<command> ::= <attributes>;
<command> ::= <attribute> OP_ASSIGN <exp>;
// INPUT / OUTPUT
<command> ::= PRINT SUBGROUP_OPEN STRING SUBGROUP_CLOSE;
<command> ::= <attribute> OP_ASSIGN INPUT SUBGROUP_OPEN SUBGROUP_CLOSE;
//<command> ::= <array> OP_ASSIGN <array_values>;
<command> ::= FUNCTION <parameter_list> | <attribute> OP_ASSIGN FUNCTION <parameter_list>;
// Conditional
<command> ::= <if>;
<command> ::= <if> <else>;
<command> ::= <if> <elsif>;
<command> ::= <if> <elsif> <else>;
// Loop
<command> ::= <while>;
<command> ::= <do_while>;
<command> ::= <for>;
<command> ::= RETURN <exp>;

<array> ::= VAR <array_size> | CONST <array_size>;
<attribute> ::= VAR | CONST | VAR <array_size> | CONST <array_size>;
<attributes> ::= <attribute> | <attribute> COMMA <attributes>;

<if> ::= IF SUBGROUP_OPEN <exp> SUBGROUP_CLOSE <scope>;
<else> ::= ELSE <scope>;
<elsif> ::= <single_elsif> | <single_elsif> <elsif>;
<single_elsif> ::= ELSIF SUBGROUP_OPEN <exp> SUBGROUP_CLOSE <scope>;

<while> ::= WHILE SUBGROUP_OPEN <exp> SUBGROUP_CLOSE <scope>;
<do_while> ::= DO <scope> WHILE SUBGROUP_OPEN <exp> SUBGROUP_CLOSE;
<for>  ::=  FOR SUBGROUP_OPEN <range> SUBGROUP_CLOSE <scope>;

// Expressions
<exp>  ::= <exp> OP_OR <exp1> | <exp1>;
<exp1> ::= <exp1> OP_AND <exp2> | <exp2>;
<exp2> ::= <exp2> OP_BW_OR <exp3> | <exp3>;
<exp3> ::= <exp3> OP_BW_XOR <exp4> | <exp4>;
<exp4> ::= <exp4> OP_BW_AND <exp5> | <exp5>;
<exp5> ::= <exp5> <op_relational> <exp6> | <exp6>;
<exp6> ::= <exp6> <op_bitwise> <exp7> | <exp7>;
<exp7> ::= <exp7> <op_arithmetic_low> <exp8> | <exp8>;
<exp8> ::= <exp8> <op_arithmetic_high> <exp9> | <exp9> ;
<exp9> ::= <op_negate> <exp10> | <exp10>;
<exp10> ::= INT | FLOAT | BOOLEAN | VAR | <array> | SUBGROUP_OPEN <exp> SUBGROUP_CLOSE;

//range for loop
<range> ::= <attribute> IN RANGE SUBGROUP_OPEN <range_types> SUBGROUP_CLOSE;
<range_types> ::= INT | INT COMMA  INT | INT COMMA INT COMMA INT;
// Operations
<op_relational> ::= OP_GT | OP_LT | OP_GTE | OP_LTE | OP_EQ | OP_NEQ; 
<op_negate> ::= OP_SUB | OP_BW_NOT | OP_NOT;
<op_bitwise> ::= OP_BW_LS | OP_BW_RS;
<op_arithmetic_low> ::= OP_ADD | OP_SUB;
<op_arithmetic_high> ::= OP_MULT | OP_DIV | OP_MOD;

// Expression test
// -$x + 8.8 - !$x * 2 / ~$y % 3 << 7 != $y >> 3 || ($x <= 3 && $y > 8) | $p & ($h ^ $g)
