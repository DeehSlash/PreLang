#Options
GenerateScanner = true
GenerateParser = true
Language = Java
ScannerName = Lexico
ParserName = Sintatico
SemanticName = Semantico
ScannerCaseSensitive = true
ScannerTable = Compact
Input = Stream
Parser = SLR
#RegularDefinitions
ignore: [\t\r\s]+|(#.*)|(##(.|\n)*##)
identifier: [a-zA-Z_][a-zA-Z0-9_]*

// TYPES
int: [0-9]+
float: [0-9]*\.[0-9]+
boolean: true | TRUE | false | FALSE
binary: 0b[0-1]+
hexadecimal: 0x[0-9a-fA-F]+
string: \"[^\"]*\"
#Tokens
: {ignore}
NEW_LINE: \n

MAIN_FUNCTION: "@main"

VAR: "$"{identifier}
CONST: "&"{identifier}
FUNCTION: "@"{identifier}

// CONDITIONAL
IF: "if"
ELSE: "else"
ELSIF: "elsif"
SWITCH: "switch"
CASE: "case"
DEFAULT: "default"

// LOOP
WHILE: "while"
DO: "do"
FOR: "for"
CONTINUE: "continue"

// OTHERS RESERVED WORDS
BREAK: "break" 
COMMA: ","
STRUCTURE_REFERENCE: "."
COLON: ":"
RETURN: "return"
IN: "in"
NULL: "null"

FUNCTION_RETURN: "->"

SCOPE_OPEN: "{"
SCOPE_CLOSE: "}"

SUBGROUP_OPEN: "("
SUBGROUP_CLOSE: ")"

INDEX_OPEN: "["
INDEX_CLOSE: "]"

// VALUES
INT: {int}
FLOAT: {float}
BOOLEAN: {boolean}
BINARY: {binary}
HEXADECIMAL: {hexadecimal}
STRING: {string}

// ARITHMETIC OPERATORS
OP_ASSIGN: "="
OP_ADD: "+"
OP_SUB: "-"
OP_MULT: "*"
OP_DIV: "/"
OP_MOD: "%"
OP_POW: "^"
OP_INC: "++"
OP_DEC: "--"

// RELATIONAL OPERATORS
OP_LT: "<"
OP_LTE: "<="
OP_EQ: "=="
OP_NEQ: "!="
OP_GT: ">"
OP_GTE: ">="

// LOGICAL OPERATORS
OP_AND: "&&"
OP_OR: "||"
OP_NOT: "!"

// BITWISE OPERATORS
OP_BW_NOT: "~"
OP_BW_AND: "&"
OP_BW_OR: "|"
OP_BW_XOR: "^"
OP_BW_LS: "<<"
OP_BW_RS: ">>"

// PRIMITIVE TYPES
TYPE_VOID: "void"
TYPE_INT: "int"
TYPE_FLOAT: "float"
TYPE_DOUBLE: "double"
TYPE_STRING: "string"
TYPE_CHAR: "char"
TYPE_BOOLEAN: "boolean"
#NonTerminals
<program>
<main_function>
<function_list>
<function>

<fn_parameter_list>
<fn_parameters>
<fn_parameter>

<parameter_list>
<parameters>
<parameter>

<type>
<type_values>
<array>
<new_line>

<command_list>
<command>
#Grammar
<program> ::= <new_line> <main_function> | <new_line> <function_list> <main_function>;
<main_function> ::= MAIN_FUNCTION <fn_parameter_list> FUNCTION_RETURN <type> SCOPE_OPEN <new_line> <command_list> SCOPE_CLOSE <new_line>;
<function_list> ::= <function> | <function> <function_list>;
<function> ::= FUNCTION <fn_parameter_list> FUNCTION_RETURN <type> SCOPE_OPEN <new_line> <command_list> SCOPE_CLOSE <new_line>;

<fn_parameter_list> ::= SUBGROUP_OPEN <fn_parameters> SUBGROUP_CLOSE | SUBGROUP_OPEN SUBGROUP_CLOSE;
<fn_parameters> ::= <fn_parameter> | <fn_parameter> COMMA <fn_parameters>;
<fn_parameter> ::= VAR COLON <type>;

<parameter_list> ::= SUBGROUP_OPEN <parameters> SUBGROUP_CLOSE | SUBGROUP_OPEN SUBGROUP_CLOSE;
<parameters> ::= <parameter> | <parameter> COMMA <parameters>;
<parameter> ::= VAR | <type_values>;

<type> ::= TYPE_INT | TYPE_FLOAT | TYPE_DOUBLE | TYPE_STRING | TYPE_CHAR | TYPE_BOOLEAN;
<type_values> ::= INT | FLOAT | BOOLEAN | BINARY | HEXADECIMAL | STRING | <array>;
<array> ::= INDEX_OPEN <parameters> INDEX_CLOSE;
<new_line> ::= NEW_LINE | NEW_LINE <new_line>;

<command_list> ::= <command> <new_line> | <command> <new_line> <command_list>;
<command> ::= VAR OP_ASSIGN VAR | VAR OP_ASSIGN CONST | VAR OP_ASSIGN <type_values>;
<command> ::= CONST OP_ASSIGN CONST | CONST OP_ASSIGN VAR | CONST OP_ASSIGN <type_values>;
<command> ::= FUNCTION <parameter_list> | VAR OP_ASSIGN FUNCTION <parameter_list>;


